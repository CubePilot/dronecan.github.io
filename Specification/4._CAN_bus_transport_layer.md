---
---

# CAN bus transport layer

## The concept of transfer

*Transfer* is a momentary act of data transmission between nodes.
A transfer that is addressed to all nodes except the source node is a *broadcast transfer*.
A transfer that is addressed to one particular node is a *unicast transfer*.
UAVCAN defines the following types of transfers:

* Message transfer - a broadcast transfer that contains a serialized message.
* Service transfer - a unicast transfer that contains either a service request or a service response.

Both message and service transfers can be further distinguished between:

* Single-frame transfer - a transfer that is entirely contained in a single CAN frame.
* Multi-frame transfer - a transfer whose payload is distributed over multiple CAN frames.

The following properties are common to all types of transfer:

Property        | Description
----------------|------------------------------------------------------------------------------------------------------
Payload         | The serialized data structure
Data type ID    | This identifier indicates how the data structure should be interpreted
Priority        | See below
Transfer ID     | An integer value that allows receiving nodes to distinguish this transfer from others

The transfer priority is an integer number that defines the urgency of the data contained in the transfer.
Numerically lower priority values indicate higher urgency, and humerically higher values indicate lower urgency.
Transfers of higher priority (i.e. with numerically lower priority value) can delay transmission of transfers
whose priority are lower (i.e. numerically higher).

### Message broadcasting

A broadcasted message is represented by a single message transfer that contains the serialized message.
A broadcasted message has the following properties:

Property        | Description
----------------|------------------------------------------------------------------------------------------------------
Payload         | The serialized message
Data type ID    | This identifier indicates how the message should be interpreted
Source node ID  | Node ID of the node that has transmitted the transfer
Priority        | See above
Transfer ID     | See above

In order to broadcast a message, the broadcasting node must have a node ID that is unique within the network.
An exception is applied to *anonymous message transfers*.

#### Anonymous message broadcasting

Anonymous message is a message that originates from a node that doesn't have a node ID.
This sort of message transfer is useful for dynamic node ID allocation purposes - a high-level concept that
will be explained in the following parts of the specification.

An anonymous message has the same properties as a regular message, except for source node ID.

Note that anonymous messages require specific arbitration rules and have restrictions on the acceptable
data type ID values.
The details are explained in the following chapters.

#### Timing

Message transmission should be aborted if it could not be completed in 1 second or less.

### Service invocation

A service invocation consists of two service transfers:

1. *Service request transfer* - from the node that invokes the service, known as *client*, to the node that provides
the service, known as *server*.
2. *Service response transfer* - once the server node receives the service request and processes it, it sends a
response transfer back to the client.

A service request transfer has the following properties:

Property                | Description
------------------------|------------------------------------------------------------------------------------------------------
Payload                 | The serialized request structure
Data type ID            | This identifier indicates how the request should be interpreted
Source node ID          | Node ID of the client
Destination node ID     | Node ID of the server
Priority                | See above
Transfer ID             | An integer value that serves two purposes: 1. allows the server to distinguish this request from other requests from the same client; 2. allows the client to match the response with request

A service response transfer has the following properties:

Property                | Description
------------------------|------------------------------------------------------------------------------------------------------
Payload                 | The serialized response structure
Data type ID            | Must be the same value as in the request transfer
Source node ID          | Node ID of the server
Destination node ID     | Node ID of the client
Priority                | Should be the same value as in the request transfer
Transfer ID             | Must be the same value as in the request transfer

Both client and server must have node ID values that are unique within the network.

#### Timing

The following timings should be used, unless the application strongly requires different values:

* Service transfer transmission should be aborted if it could not complete in 0.5 seconds.
* The client should stop waiting for response from the server if the response did not arrive in 0.5 seconds.
* The server should be able to process any request in under 0.25 seconds.

If different values are used, they must be explicitly documented.

## Transmission

### Transfer ID computation

Transfer ID is a small unsigned integer value that is assigned to every outgoing transfer.
For message transfers and service request transfers the transfer ID value should be computed as described below.
For service response transfers, however, this value must be directly copied from the corresponding service request
transfer, which has been mentioned earlier in this section.

The transfer ID computation logic relies on the concept of *transfer descriptor*.
Transfer descriptor is a set of properties that identify a particular set of transfers that originate from
the same node, share the same data type ID and the same type.
The properties that constitute a transfer descriptor are listed below:

* Transfer type (message broadcasting, service request, etc.)
* Data type ID
* Source node ID
* Destination node ID (only for unicast transfers)

Every node that needs to publish a transfer must maintain the mapping from transfer desciptor to transfer ID.
This mapping will be referred to as *transfer ID map*.

Whenever a node needs to emit a transfer, it will query its transfer ID map for the appropriate transfer descriptor.
If the map does not contain such entry, a new entry will be created with transfer ID initialized to zero.
The node will use the current value of transfer ID from the map for the transfer, and then the value stored in the map
will be incremented by one.
When the stored transfer ID exceeds its maximum value, it will roll over to zero.

It is expected that some nodes will need to publish certain transfers aperiodically or ad-hoc, therefore creating
unused entries in the transfer ID map.
In order to avoid keeping unused entries in the map, the nodes are allowed, but not required,
to remove entries from the map that were not used for at least 2 seconds.
Therefore, it is possible that a node may publish a transfer with an out-of-order transfer ID value, if previous
transfer of the same descriptor has been published more than 2 seconds ago.

### Payload decomposition

#### Single frame transfer

If size of the entire transfer payload does not exceed the space available for payload in a single CAN frame,
the whole transfer will be contained in one CAN frame. Such transfer is called a *single-frame transfer*.

Single frame transfers are more efficient than multi-frame transfers in terms of throughput and latency,
therefore it is adviced to avoid the latter when appropriate.

#### Multi-frame transfer

*Multi-frame transfers* are used when the size of the transfer payload exceeds the space available for payload in a
single CAN frame.

Two new concepts are introduced in the context of multi-frame transfers, both of them are reviewed below in detail:

* Transfer CRC
* Toggle bit

In order to emit a multi-frame transfer, the node must compute the CRC for the transfer payload as described in the
following chapter, then prepend the payload with the computed CRC value, and then emit a sequence of CAN frames
containing the chunks of payload ordered so that the first frame contains first bytes of the payload and the CRC,
and the last frame contains the last bytes of the payload.
The payload field of all CAN frames of a multi-frame transfer, except the last one, must be fully utilized.

##### Transfer CRC

Transfer CRC is computed from the transfer payload prepended with a data type signature in little-endian byte order.
The diagram below illustrates the input of the transfer CRC function:

<img src="figures/transfer_crc_input.png" style="max-width: 100%"/>

The transfer CRC algorithm is specified as follows:

* Name: CRC-16-CCITT-FALSE
* Description: <http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat.crc-16-ccitt-false>
* Initial value: 0xFFFF
* Poly: 0x1021
* Reverse: no
* Output XOR: 0
* Check: 0x29B1

The following code provides an implementation of the transfer CRC algorithm in C++:

```c++
/*
 * License: CC0, no copyright reserved.
 */

#include <iostream>
#include <cstdint>
#include <cassert>

class TransferCRC
{
    std::uint16_t value_;

public:
    TransferCRC()
        : value_(0xFFFFU)
    { }

    void add(std::uint8_t byte)
    {
        value_ ^= static_cast<std::uint16_t>(byte) << 8;
        for (std::uint8_t bit = 8; bit > 0; --bit)
        {
            if (value_ & 0x8000U)
            {
                value_ = (value_ << 1) ^ 0x1021U;
            }
            else
            {
                value_ = (value_ << 1);
            }
        }
    }

    void add(const std::uint8_t* bytes, unsigned len)
    {
        assert(bytes);
        while (len--)
        {
            add(*bytes++);
        }
    }

    std::uint16_t get() const { return value_; }
};

int main()
{
    TransferCRC crc;
    crc.add(reinterpret_cast<const std::uint8_t*>("123456789"), 9);
    std::cout << std::hex << "0x" << crc.get() << std::endl;
}
```

##### Toggle bit

Toggle bit is a property defined at the CAN frame level.
Its purpose is to detect and avoid CAN frame duplication errors.

The toggle bit of the first CAN frame of a multi-frame transfer must be set to zero.
The toggle bits of the following CAN frames of the transfer must alternate,
i.e. the toggle bit of the second CAN frame will be one, the toggle bit of the third CAN frame will be zero,
and so on.








